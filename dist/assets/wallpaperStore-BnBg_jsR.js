const w="glassy-wallpapers";const c="wallpapers",a=typeof indexedDB<"u";function p(){return a?new Promise((n,o)=>{const e=indexedDB.open(w,1);e.onupgradeneeded=()=>{const t=e.result;t.objectStoreNames.contains(c)||t.createObjectStore(c,{keyPath:"id"}).createIndex("createdAt","createdAt")},e.onsuccess=()=>n(e.result),e.onerror=()=>o(e.error)}):Promise.reject(new Error("IndexedDB is not available in this environment"))}async function i(n="readonly"){const e=(await p()).transaction(c,n),t=e.objectStore(c);return{tx:e,store:t}}async function f(n,o){if(!a)throw new Error("IndexedDB not available");const{tx:e,store:t}=await i("readwrite"),s={id:crypto.randomUUID(),name:o,createdAt:Date.now()};return await new Promise((l,u)=>{const d=t.put({...s,blob:n});d.onsuccess=()=>l(),d.onerror=()=>u(d.error)}),{...s,url:URL.createObjectURL(n)}}async function b(){if(!a)return[];const{tx:n,store:o}=await i("readonly"),e=o.getAll();return(await new Promise((r,s)=>{e.onsuccess=()=>r(e.result),e.onerror=()=>s(e.error)})).sort((r,s)=>(s.createdAt??0)-(r.createdAt??0)).map(r=>({id:r.id,name:r.name,createdAt:r.createdAt,url:URL.createObjectURL(r.blob)}))}async function y(n){if(!a)return;const{store:o}=await i("readwrite");await new Promise((e,t)=>{const r=o.delete(n);r.onsuccess=()=>e(),r.onerror=()=>t(r.error)})}async function D(n){if(!a)return null;const{store:o}=await i("readonly"),e=o.get(n),t=await new Promise((r,s)=>{e.onsuccess=()=>r(e.result),e.onerror=()=>s(e.error)});return(t==null?void 0:t.blob)??null}export{y as deleteWallpaper,D as getWallpaperBlob,b as listWallpapers,f as saveWallpaper};
